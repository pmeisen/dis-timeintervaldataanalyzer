package net.meisen.dissertation.model.dimensions;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import net.meisen.dissertation.exceptions.DescriptorDimensionException;
import net.meisen.general.genmisc.exceptions.ForwardedRuntimeException;

/**
 * Manager to manage and organize the {@code DescriptorMember} instances of a
 * {@code DescriptorHierarchy}.
 * 
 * @author pmeisen
 * 
 */
public class DescriptorMemberManager {
	private final DescriptorHierarchy descriptorHierarchy;
	private final Map<String, DescriptorMember> members;

	/**
	 * The default constructor specifying the hierarchy.
	 * 
	 * @param descriptorHierarchy
	 *            the hierarchy the manager belongs to
	 */
	public DescriptorMemberManager(final DescriptorHierarchy descriptorHierarchy) {
		this.descriptorHierarchy = descriptorHierarchy;
		this.members = new HashMap<String, DescriptorMember>();
	}

	/**
	 * Adds a member to the manager by creating it.
	 * 
	 * @param id
	 *            the identifier to be used
	 * @param name
	 *            the name to be used
	 * @param pattern
	 *            the pattern to be used
	 * @param includeNull
	 *            {@code true} if {@code null} should be included, otherwise
	 *            {@code false}
	 * @param level
	 *            the level the member belongs to
	 * @param rollUpTo
	 *            the members to roll up to
	 * 
	 * @return the created and added, or found member
	 * 
	 * @throws ForwardedRuntimeException
	 *             if the member could not be created, e.g. because the
	 *             identifier is used by another member
	 */
	public DescriptorMember addMember(final String id, final String name,
			final String pattern, final boolean includeNull,
			final DescriptorLevel level, final Collection<String> rollUpTo)
			throws ForwardedRuntimeException {
		DescriptorMember member = this.members.get(id);
		if (member == null) {
			member = new DescriptorMember(descriptorHierarchy, id, name,
					pattern, includeNull, level, resolve(rollUpTo));
			this.members.put(id, member);
		} else {
			if (member.isAutoGenerated()) {
				member.setName(name);
				member.setPattern(pattern);
				member.setLevel(level);
				member.setRollUpTo(resolve(rollUpTo));
				member.setAutoGenerated(false);
			} else {
				throw new ForwardedRuntimeException(
						DescriptorDimensionException.class, 1004, id,
						this.members.get(id));
			}
		}

		return member;
	}

	/**
	 * Resolves the collection of member-identifiers specified.
	 * 
	 * @param rollUpTo
	 *            the identifiers of the members to be resolved
	 * 
	 * @return the resolved members
	 */
	protected List<DescriptorMember> resolve(final Collection<String> rollUpTo) {
		final List<DescriptorMember> rollUpToMembers = new ArrayList<DescriptorMember>();

		if (rollUpTo == null) {

			// when we found a null, we add the root
			final DescriptorMember member = getMember(DescriptorDimension.ROOT_MEMBER_ID);

			/*
			 * in the case the root is not available, it is probably the root
			 * itself being added
			 */
			if (member != null) {
				rollUpToMembers.add(member);
			}
		} else {

			// generate the roll-up members
			for (final String memberId : rollUpTo) {
				DescriptorMember member = getMember(memberId);
				if (member == null) {
					member = descriptorHierarchy.addMember(memberId,
							DescriptorDimension.UNASSIGNED_LEVEL_ID, null);
					member.setAutoGenerated(true);
					this.members.put(memberId, member);
				}

				rollUpToMembers.add(member);
			}
		}

		return rollUpToMembers;
	}

	/**
	 * Gets the member with the specified {@code id} from the manager.
	 * 
	 * @param id
	 *            the identifier of the member to retrieve
	 * 
	 * @return the member associated, might be {@code null} if no member is
	 *         associated to the member
	 */
	public DescriptorMember getMember(final String id) {
		return members.get(id);
	}

	/**
	 * Gets all the members of the specified level.
	 * 
	 * @param levelId
	 *            the identifier of the level to get the members for
	 * 
	 * @return a collection of all the members associated to the specified
	 *         {@code levelId}, never {@code null}
	 */
	public Collection<DescriptorMember> getMembers(final String levelId) {
		final List<DescriptorMember> members = new ArrayList<DescriptorMember>();

		for (final DescriptorMember member : this.members.values()) {
			if (member.getLevel().getId().equals(levelId)) {
				members.add(member);
			}
		}

		return members;
	}

	/**
	 * Get all the members of the manager.
	 * 
	 * @return the members of the manager
	 */
	public Collection<DescriptorMember> getMembers() {
		return Collections.unmodifiableCollection(members.values());
	}
}
